{"version":3,"sources":["helpers/Valid.js","utils/RenderEngine/Rectangle.js","utils/RenderEngine/Shader/index.js","utils/RenderEngine/index.js","components/App.js","serviceWorker.js","index.js"],"names":["isUndefined","data","undefined","Rectangle","props","Object","classCallCheck","this","uuid","_this","allValid","forEach","p","Valid","_this$props","x","y","width","height","halfWidth","halfHeight","positions","Shader","vsSource","fsSource","loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","deleteShader","initShaderProgram","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","utils_RenderEngine","displayObjects","canvasId","document","getElementById","getContext","clearColor","programInfo","program","attribLocations","vertexPosition","getAttribLocation","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","position","clear","COLOR_BUFFER_BIT","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","DEPTH_BUFFER_BIT","fieldOfView","Math","PI","aspect","canvas","clientWidth","clientHeight","mat4","create","perspective","translate","FLOAT","rect","rectBuffer","initBuffers","vertexAttribPointer","enableVertexAttribArray","useProgram","uniformMatrix4fv","drawArrays","TRIANGLE_STRIP","id","App","RenderEngine","init","drawScene","react_default","a","createElement","className","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_components_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9a824f9f.chunk.js","sourcesContent":["/**\n * @function isUndefined\n * @param {any} data - Any type of data\n * @return If the data is undefined\n */\nconst isUndefined = (data) => {\n  return data === undefined;\n};\n\nexport {\n  isUndefined\n};\n","import uuid from 'uuid';\nimport { Valid } from '../../helpers';\n\n/** Rectangle lib */\nclass Rectangle {\n  constructor(props) {\n    this.uuid = uuid();\n    this.props = props;\n  }\n\n  positions() {\n    // Check if has x, y, width and height\n    let allValid = true;\n    ['x', 'y', 'width', 'height'].forEach(p => {\n      if (Valid.isUndefined(this.props[p])) {\n        allValid = false;\n      }\n    });\n\n    if (allValid) {\n      const { x, y, width, height } = this.props;\n\n      if (width > 0 && height > 0) {\n        // Calculate rectangle position with x, y, width and height\n        const halfWidth = width / 2;\n        const halfHeight = height / 2;\n        const positions = [\n          x - halfWidth, y - halfHeight, // Left-Top\n          x + halfWidth, y - halfHeight, // Right-Top\n          x - halfWidth, y + halfHeight, // Left-Bottom\n          x + halfWidth, y + halfHeight  // Right-Bottom\n        ];\n\n        return positions;\n      }\n    }\n\n    return null;\n  }\n}\n\nexport default Rectangle;\n","/** Shader lib */\nconst Shader = {\n  // Vertex shader program\n  vsSource: `\n    attribute vec4 aVertexPosition;\n\n    uniform mat4 uModelViewMatrix;\n    uniform mat4 uProjectionMatrix;\n\n    void main() {\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n    }\n  `,\n\n  fsSource: `\n    void main() {\n      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n  `,\n\n  /**\n   * @function loadShader\n   * @description Create a shader of the giver type, uploads the source and compiles it.\n   */\n  loadShader: (gl, type, source) => {\n    const shader = gl.createShader(type);\n\n    // Send the source to the shader object\n    gl.shaderSource(shader, source);\n\n    // Compile the shader program\n    gl.compileShader(shader);\n\n    // See if it compiled successfully\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  },\n\n  /**\n   * @function initShaderProgram\n   * @description Initial shader program with WebGL\n   */\n  initShaderProgram: (gl, vsSource, fsSource) => {\n    const vertexShader = Shader.loadShader(gl, gl.VERTEX_SHADER, vsSource);\n    const fragmentShader = Shader.loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\n\n    // Create shader program\n    const shaderProgram = gl.createProgram();\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    // Error handle\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\n      return null;\n    }\n\n    return shaderProgram;\n  }\n};\n\nexport default Shader;\n","import Rectangle from './Rectangle';\nimport Shader from './Shader';\nimport { mat4 } from 'gl-matrix';\n\n/** Render engine for WebGL */\nclass RenderEngine {\n  /** Map of all display objects */\n  displayObjects = {}\n\n  /**\n   * @function init\n   * @description Init WebGL to specific canvas\n   */\n  init(canvasId) {\n    const canvas = document.getElementById(canvasId);\n    const gl = canvas.getContext('webgl');\n    this.gl = gl;\n\n    if (gl === null) {\n      alert(\"Can't initialize WebGL that your browser doesn't support it\");\n      return;\n    }\n\n    // Clear background\n    gl.clearColor(0, 0, 0, 1);\n    const shaderProgram = Shader.initShaderProgram(gl, Shader.vsSource, Shader.fsSource);\n    this.programInfo = {\n      program: shaderProgram,\n      attribLocations: {\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\n      },\n      uniformLocations: {\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\n      },\n    };\n  }\n\n  /**\n   * @function initBuffers\n   * @param {array} positions - position list of the shape\n   * @return The object of the position buffer\n   */\n  initBuffers(positions) {\n    const gl = this.gl;\n\n    // Create position buffer\n    const positionBuffer = gl.createBuffer();\n\n    // Select the positionBuffer as the one to apply buffer operations to from here out.\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    // Now pass the list of positions into WebGL to build the\n    // shape. We do this by creating a Float32Array from the\n    // JavaScript array, then use it to fill the current buffer.\n    gl.bufferData(gl.ARRAY_BUFFER,\n                new Float32Array(positions),\n                gl.STATIC_DRAW);\n\n    return {\n      position: positionBuffer,\n    };\n  }\n\n  drawScene() {\n    const gl = this.gl;\n    gl.clear(gl.COLOR_BUFFER_BIT);   // 設定為全黑\n    gl.clearDepth(1.0);                   // 清除所有東西\n    gl.enable(gl.DEPTH_TEST);        // Enable 深度測試\n    gl.depthFunc(gl.LEQUAL);         // Near things obscure far things\n\n    // Initial canvas\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    // Create a perspective matrix, a special matrix that is\n    // used to simulate the distortion of perspective in a camera.\n    // Our field of view is 45 degrees, with a width/height\n    // ratio that matches the display size of the canvas\n    // and we only want to see objects between 0.1 units\n    // and 100 units away from the camera.\n    const fieldOfView = 45 * Math.PI / 180;   // in radians\n    const aspect = (gl.canvas.clientWidth / gl.canvas.clientHeight) * 1;\n    const zNear = 0.1;\n    const zFar = 300.0;\n    const projectionMatrix = mat4.create();\n\n    // note: glmatrix.js always has the first argument\n    // as the destination to receive the result.\n    mat4.perspective(projectionMatrix,\n                     fieldOfView,\n                     aspect,\n                     zNear,\n                     zFar);\n\n    // Set the drawing position to the \"identity\" point, which is\n    // the center of the scene.\n    const modelViewMatrix = mat4.create();\n\n    // Now move the drawing position a bit to where we want to\n    // start drawing the square.\n\n    mat4.translate(modelViewMatrix,     // destination matrix\n                   modelViewMatrix,     // matrix to translate\n                   [-0.0, 0.0, -300.0]);  // amount to translate\n\n    // Tell WebGL how to pull out the positions from the position\n    // buffer into the vertexPosition attribute.\n    {\n      const numComponents = 2;  // pull out 2 values per iteration\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\n      const normalize = false;  // don't normalize\n      const stride = 0;         // how many bytes to get from one set of values to the next\n                                // 0 = use type and numComponents above\n      const offset = 0;         // how many bytes inside the buffer to start from\n      const rect = new Rectangle({ x: 0, y: 0, width: 100, height: 100 });\n      const rectBuffer = this.initBuffers(rect.positions());\n      gl.bindBuffer(gl.ARRAY_BUFFER, rectBuffer.position);\n      gl.vertexAttribPointer(\n          this.programInfo.attribLocations.vertexPosition,\n          numComponents,\n          type,\n          normalize,\n          stride,\n          offset);\n      gl.enableVertexAttribArray(\n          this.programInfo.attribLocations.vertexPosition);\n    }\n\n    // Tell WebGL to use our program when drawing\n    gl.useProgram(this.programInfo.program);\n\n    // Set the shader uniforms\n    gl.uniformMatrix4fv(\n        this.programInfo.uniformLocations.projectionMatrix,\n        false,\n        projectionMatrix);\n    gl.uniformMatrix4fv(\n        this.programInfo.uniformLocations.modelViewMatrix,\n        false,\n        modelViewMatrix);\n\n    {\n      const offset = 0;\n      const vertexCount = 4;\n      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\n    }\n  }\n\n  /**\n   * @function drawRectangle\n   * @param {object} props - All props that a Rectangle needs\n   */\n  drawRectangle(props) {\n    const rect = new Rectangle(this, props);\n    this.displayObjects[rect.id] = rect;\n  }\n};\n\nexport default new RenderEngine();\n","import React, { Component } from 'react';\nimport RenderEngine from '../utils/RenderEngine';\nimport './App.css';\n\nclass App extends Component {\n  componentDidMount() {\n    RenderEngine.init('glCanvas');\n    RenderEngine.drawScene();\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <canvas id=\"glCanvas\" />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}