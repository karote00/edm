{"version":3,"sources":["helpers/valid.js","utils/RenderEngine/Rectangle.js","utils/RenderEngine/index.js","utils/RenderEngine/Shader/index.js","components/App.js","serviceWorker.js","index.js"],"names":["isUndefined","data","undefined","Rectangle","props","Object","classCallCheck","this","uuid","_this","allValid","forEach","p","Valid","_this$props","x","y","width","height","halfWidth","halfHeight","positions","utils_RenderEngine","displayObjects","canvasId","gl","document","getElementById","getContext","clearColor","shaderProgram","initShaderProgram","programInfo","program","attribLocations","vertexPosition","getAttribLocation","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","alert","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","position","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","vsSource","fsSource","vertexShader","loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","clear","COLOR_BUFFER_BIT","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","DEPTH_BUFFER_BIT","fieldOfView","Math","PI","aspect","canvas","clientWidth","clientHeight","mat4","create","perspective","translate","FLOAT","rect","rectBuffer","initBuffers","vertexAttribPointer","enableVertexAttribArray","useProgram","uniformMatrix4fv","drawArrays","TRIANGLE_STRIP","id","App","RenderEngine","init","drawScene","react_default","a","createElement","className","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_components_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.27a7ab39.chunk.js","sourcesContent":["const isUndefined = (data) => {\n  return data === undefined;\n};\n\nexport {\n  isUndefined\n};\n","import uuid from 'uuid';\nimport { Valid } from '../../helpers';\n\n/** Rectangle lib */\nclass Rectangle {\n  constructor(props) {\n    this.uuid = uuid();\n    this.props = props;\n  }\n\n  positions() {\n    // Check if has x, y, width and height\n    let allValid = true;\n    ['x', 'y', 'width', 'height'].forEach(p => {\n      if (Valid.isUndefined(this.props[p])) {\n        allValid = false;\n      }\n    });\n\n    if (allValid) {\n      const { x, y, width, height } = this.props;\n\n      if (width > 0 && height > 0) {\n        // Calculate rectangle position with x, y, width and height\n        const halfWidth = width / 2;\n        const halfHeight = height / 2;\n        const positions = [\n          x - halfWidth, y - halfHeight, // Left-Top\n          x + halfWidth, y - halfHeight, // Right-Top\n          x - halfWidth, y + halfHeight, // Left-Bottom\n          x + halfWidth, y + halfHeight  // Right-Bottom\n        ];\n\n        return positions;\n      }\n    }\n\n    return null;\n  }\n}\n\nexport default Rectangle;\n","import Rectangle from './Rectangle';\nimport { vsSource, fsSource } from './Shader';\nimport { mat4 } from 'gl-matrix';\n\n/** Render engine for WebGL */\nclass RenderEngine {\n  /** Map of all display objects */\n  displayObjects = {}\n\n  /**\n   * @function init\n   * @description Init WebGL to specific canvas\n   */\n  init(canvasId) {\n    const canvas = document.getElementById(canvasId);\n    const gl = canvas.getContext('webgl');\n    this.gl = gl;\n\n    if (gl === null) {\n      alert(\"Can't initialize WebGL that your browser doesn't support it\");\n      return;\n    }\n\n    // Clear background\n    gl.clearColor(0, 0, 0, 1);\n\n    const shaderProgram = this.initShaderProgram(vsSource, fsSource);\n    this.programInfo = {\n      program: shaderProgram,\n      attribLocations: {\n        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\n      },\n      uniformLocations: {\n        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\n        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\n      },\n    };\n  }\n\n  initBuffers(positions) {\n    const gl = this.gl;\n\n    // Create position buffer\n    const positionBuffer = gl.createBuffer();\n\n    // Select the positionBuffer as the one to apply buffer operations to from here out.\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    // Now pass the list of positions into WebGL to build the\n    // shape. We do this by creating a Float32Array from the\n    // JavaScript array, then use it to fill the current buffer.\n    gl.bufferData(gl.ARRAY_BUFFER,\n                new Float32Array(positions),\n                gl.STATIC_DRAW);\n\n    return {\n      position: positionBuffer,\n    };\n  }\n\n  /**\n   * @function loadShader\n   * @description Create a shader of the giver type, uploads the source and compiles it.\n   */\n  loadShader(type, source) {\n    const gl = this.gl;\n    const shader = gl.createShader(type);\n\n    // Send the source to the shader object\n    gl.shaderSource(shader, source);\n\n    // Compile the shader program\n    gl.compileShader(shader);\n\n    // See if it compiled successfully\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  }\n\n  /**\n   * @function initShaderProgram\n   * @description Initial shader program with WebGL\n   */\n  initShaderProgram(vsSource, fsSource) {\n    const gl = this.gl;\n    const vertexShader = this.loadShader(gl.VERTEX_SHADER, vsSource);\n    const fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fsSource);\n\n    // Create shader program\n    const shaderProgram = this.gl.createProgram();\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    // Error handle\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\n      return null;\n    }\n\n    return shaderProgram;\n  }\n\n  drawScene() {\n    const gl = this.gl;\n    gl.clear(gl.COLOR_BUFFER_BIT);   // 設定為全黑\n    gl.clearDepth(1.0);                   // 清除所有東西\n    gl.enable(gl.DEPTH_TEST);        // Enable 深度測試\n    gl.depthFunc(gl.LEQUAL);         // Near things obscure far things\n\n    // Initial canvas\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    // Create a perspective matrix, a special matrix that is\n    // used to simulate the distortion of perspective in a camera.\n    // Our field of view is 45 degrees, with a width/height\n    // ratio that matches the display size of the canvas\n    // and we only want to see objects between 0.1 units\n    // and 100 units away from the camera.\n    const fieldOfView = 45 * Math.PI / 180;   // in radians\n    const aspect = (gl.canvas.clientWidth / gl.canvas.clientHeight) * 1;\n    const zNear = 0.1;\n    const zFar = 100.0;\n    const projectionMatrix = mat4.create();\n\n    // note: glmatrix.js always has the first argument\n    // as the destination to receive the result.\n    mat4.perspective(projectionMatrix,\n                     fieldOfView,\n                     aspect,\n                     zNear,\n                     zFar);\n\n    // Set the drawing position to the \"identity\" point, which is\n    // the center of the scene.\n    const modelViewMatrix = mat4.create();\n\n    // Now move the drawing position a bit to where we want to\n    // start drawing the square.\n\n    mat4.translate(modelViewMatrix,     // destination matrix\n                   modelViewMatrix,     // matrix to translate\n                   [-0.0, 0.0, -6.0]);  // amount to translate\n\n    // Tell WebGL how to pull out the positions from the position\n    // buffer into the vertexPosition attribute.\n    {\n      const numComponents = 2;  // pull out 2 values per iteration\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\n      const normalize = false;  // don't normalize\n      const stride = 0;         // how many bytes to get from one set of values to the next\n                                // 0 = use type and numComponents above\n      const offset = 0;         // how many bytes inside the buffer to start from\n      const rect = new Rectangle({ x: 0, y: 0, width: 2, height: 2 });\n      const rectBuffer = this.initBuffers(rect.positions());\n      gl.bindBuffer(gl.ARRAY_BUFFER, rectBuffer.position);\n      gl.vertexAttribPointer(\n          this.programInfo.attribLocations.vertexPosition,\n          numComponents,\n          type,\n          normalize,\n          stride,\n          offset);\n      gl.enableVertexAttribArray(\n          this.programInfo.attribLocations.vertexPosition);\n    }\n\n    // Tell WebGL to use our program when drawing\n    gl.useProgram(this.programInfo.program);\n\n    // Set the shader uniforms\n    gl.uniformMatrix4fv(\n        this.programInfo.uniformLocations.projectionMatrix,\n        false,\n        projectionMatrix);\n    gl.uniformMatrix4fv(\n        this.programInfo.uniformLocations.modelViewMatrix,\n        false,\n        modelViewMatrix);\n\n    {\n      const offset = 0;\n      const vertexCount = 4;\n      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\n    }\n  }\n\n  drawRectangle(props) {\n    const rect = new Rectangle(this, props);\n    this.displayObjects[rect.id] = rect;\n  }\n};\n\nexport default new RenderEngine();\n","// Vertex shader program\nconst vsSource = `\n  attribute vec4 aVertexPosition;\n\n  uniform mat4 uModelViewMatrix;\n  uniform mat4 uProjectionMatrix;\n\n  void main() {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n  }\n`;\n\nconst fsSource = `\n  void main() {\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n  }\n`;\n\nexport {\n  vsSource,\n  fsSource\n};\n","import React, { Component } from 'react';\nimport RenderEngine from '../utils/RenderEngine';\nimport './App.css';\n\nclass App extends Component {\n  componentDidMount() {\n    RenderEngine.init('glCanvas');\n    // RenderEngine.drawRectangle({ x: 0, y: 50, width: 200, height: 100 });\n    RenderEngine.drawScene();\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <canvas id=\"glCanvas\" />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}